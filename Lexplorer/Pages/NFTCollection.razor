@page "/nfts/collections/{tokenAddress}"
@using System.Diagnostics
@inject LoopringGraphQLService LoopringGraphQLService;
@inject EthereumService EthereumService;
@inject NftMetadataService NftMetadataService;
@inject NavigationManager NavigationManager;
@inject IAppCache AppCache;

<PageTitle>The Lexplorer - NFT Collection</PageTitle>

<MudContainer Fixed="true" Class="px-0 extra-extra-extra-large">
    <MudText Typo="Typo.h6">NFT Contract Address <L1AccountLink address="@tokenAddress" shortenAddress="false" /></MudText>
    <br />
    <NFTGrid @bind-PageNumber="@goToPage" NFTSlots="@collectionNFTSlots" PageCount="@maxPageCount" />
</MudContainer>

@code {
    [Parameter]
    public string? tokenAddress { get; set; }

    [Parameter]
    [SupplyParameterFromQuery]
    public string pageNumber { get; set; } = "1";

    public int goToPage
    {
        get
        {
            return int.TryParse(pageNumber, out int np) ? np : 1;
        }
        set
        {
            var URL = NavigationManager.GetUriWithQueryParameter(nameof(pageNumber), value);
            NavigationManager.NavigateTo(URL);
        }
    }

    public readonly int pageSize = 12; //6 per row

    public int maxPageCount { get; set; } = 1;

    private CancellationTokenSource? cts;
    private IList<AccountNFTSlot>? collectionNFTSlots { get; set; }
    protected override async Task OnParametersSetAsync()
    {
        //quickly and early ensure that maxPageCount never get's smaller than the page we're on
        maxPageCount = Math.Max(maxPageCount, goToPage);

        //cancel any previous OnParametersSetAsync which might still be running
        cts?.Cancel();

        using (CancellationTokenSource localCTS = new CancellationTokenSource())
        {
            //give future calls a chance to cancel us; it is now safe to replace
            //any previous value of cts, since we already cancelled it above
            cts = localCTS;
            try
            {
                if (string.IsNullOrEmpty(tokenAddress)) return;

                string collectionNftKey = $"collection-{tokenAddress}-page-{goToPage}";
                var collectionNFTs = await AppCache.GetOrAddAsyncNonNull(collectionNftKey,
                    async () => await LoopringGraphQLService.GetCollectionNFTs(tokenAddress, (goToPage - 1) * pageSize, cancellationToken: localCTS.Token),
                    DateTimeOffset.UtcNow.AddMinutes(10));
                localCTS.Token.ThrowIfCancellationRequested();
                maxPageCount = Math.Max(maxPageCount, goToPage + (collectionNFTs?.Count < pageSize ? 0 : 1));

                //transform list of nfts to list of accountsSlots with everything else empty/null
                collectionNFTSlots = collectionNFTs?.
                    Select(NFT => new AccountNFTSlot() { nft = NFT }).ToList();
            }
            catch (OperationCanceledException)
            {
            }
            catch (Exception e)
            {
                Trace.WriteLine(e.StackTrace + "\n" + e.Message);
            }
            //now for cleanup, we must clear cts, but only if it is still our localCTS, which we're about to dispose
            //otherwise a new call has already replaced cts with it's own localCTS
            Interlocked.CompareExchange<CancellationTokenSource?>(ref cts, null, localCTS);
        }
    }

 }
